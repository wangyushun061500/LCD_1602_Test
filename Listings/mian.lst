C51 COMPILER V9.59.0.0   MIAN                                                              08/15/2020 22:39:34 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MIAN
OBJECT MODULE PLACED IN .\Objects\mian.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE mian.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\mian
                    -.lst) TABS(2) OBJECT(.\Objects\mian.obj)

line level    source

   1          #include "config.h"
   2          
   3          
   4          //函数提前声明
   5          void init (void);
   6          void Delay100us();
   7          u8 LCD_Data_Read (void);
   8          void LCD_Data_Write (u8 Data);
   9          void LCD1602_wait();
  10          void LCD1602_cmd(u8 cmd);
  11          void LCD1602_Data(u8 dat);
  12          void LCD1602_Init();
  13          void LCD1602_SetRAM(u8 x,u8 y);
  14          void LCD1602_Show(u8 x,u8 y,u8 *str);
  15          void uart_init();
  16          void SendData(u8 dat);
  17          void SendString(char *s);
  18          void Delay1000ms();
  19          
  20          //变量声明
  21          bit busy;
  22          
  23          
  24          void main (void)
  25          {
  26   1          init();
  27   1          uart_init();
  28   1        T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
  29   1          T2H = (65536 - (FOSC/4/BAUD))>>8;
  30   1          AUXR = 0x14;                //T2为1T模式, 并启动定时器2
  31   1          AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
  32   1          ES = 1;                     //使能串口1中断
  33   1          EA = 1;
  34   1        Delay1000ms();
  35   1        SendString("STC15F2K60S2\r\nUart ON !\r\n");
  36   1          LCD1602_Init();
  37   1          Delay1000ms();
  38   1          LCD1602_cmd(0x80);
  39   1          LCD1602_Data('A');
  40   1          while (1)
  41   1          {
  42   2              LCD1602_cmd(0x18);
  43   2              // LCD1602_Show(2,0,"Xiaomo_HAA");
  44   2              // LCD1602_Show(0,11,"HAppy!");
  45   2              Delay1000ms();
  46   2          }
  47   1          
  48   1      }
  49          
  50          //初始化函数
  51          void init (void)
  52          {
  53   1          P0M0 = 0x03;
  54   1          P0M1 = 0x00;
C51 COMPILER V9.59.0.0   MIAN                                                              08/15/2020 22:39:34 PAGE 2   

  55   1          P1M0 = 0xe0;
  56   1          P1M1 = 0x00;
  57   1          VSS = 1;
  58   1          GND = 0;
  59   1          LEDA = 1;
  60   1          LEDK = 0;
  61   1      }
  62          
  63          //延时函数100us
  64          void Delay100us()   //@24.000MHz
  65          {
  66   1        unsigned char i, j;
  67   1      
  68   1        i = 3;
  69   1        j = 82;
  70   1        do
  71   1        {
  72   2          while (--j);
  73   2        } while (--i);
  74   1      }
  75          
  76          //读数据
  77          u8 LCD_Data_Read (void)
  78          {
  79   1           u8 Data;
  80   1           Data = (P0 >> 2) | (P1 << 6);
  81   1           Data = (Data << 4) | (Data >> 4);
  82   1           Data = ((Data >> 2) & 0x33) | ((Data << 2) & 0xcc);
  83   1           Data = ((Data >> 1) & 0x55) | ((Data << 1) & 0xaa);
  84   1           return Data;
  85   1      }
  86          
  87          //写数据
  88          void LCD_Data_Write (u8 Data)
  89          {
  90   1          D0 = (Data & 0x01);
  91   1          D1 = (bit)(Data & 0x02);
  92   1          D2 = (bit)(Data & 0x04);
  93   1          D3 = (bit)(Data & 0x08);
  94   1          D4 = (bit)(Data & 0x10);
  95   1          D5 = (bit)(Data & 0x20);
  96   1          D6 = (bit)(Data & 0x40);
  97   1          D7 = (bit)(Data & 0x80);
  98   1      }
  99          
 100          //等待操作
 101          void LCD1602_wait()
 102          {
 103   1          u8 sta;
 104   1          LCD_Data_Write(0xff);
 105   1          RS = 0;
 106   1          RW = 1;
 107   1       
 108   1          do{
 109   2              CE = 1;
 110   2              sta = LCD_Data_Read();    //读取状态字
 111   2              CE = 0;      
 112   2          }while(sta & 0x80);      //bit7等于1表示液晶正忙，重复检测直到其为0为止
 113   1      }
 114          
 115          
 116          //写命令操作
C51 COMPILER V9.59.0.0   MIAN                                                              08/15/2020 22:39:34 PAGE 3   

 117          void LCD1602_cmd(u8 cmd)
 118          {
 119   1          LCD1602_wait();
 120   1        RS = 0;                   
 121   1        RW = 0;
 122   1        LCD_Data_Write(cmd);      
 123   1        CE = 1;                 
 124   1        CE = 0;
 125   1      }
 126           
 127          //写数据操作
 128          void LCD1602_Data(u8 dat)
 129          {
 130   1          LCD1602_wait();
 131   1        RS = 1;
 132   1        RW = 0;
 133   1        LCD_Data_Write(dat);
 134   1        CE = 1;               
 135   1        CE = 0;
 136   1      }
 137          
 138          //LCD1602初始化
 139          void LCD1602_Init()
 140          {
 141   1        LCD1602_cmd(0x38);    //设置显示模式
 142   1        LCD1602_cmd(0x0e);    //开显示不显示光标，光标不闪烁
 143   1        LCD1602_cmd(0x06);    //写一个指针+1
 144   1        LCD1602_cmd(0x01);    //清屏
 145   1      }
 146          
 147          //设置显示RAM起始地址（x，y对应屏幕上字符坐标）
 148          void LCD1602_SetRAM(u8 x,u8 y)
 149          {
 150   1          u8 addr;
 151   1          if(y == 0)
 152   1              addr = 0x00 + x;
 153   1          else
 154   1              addr = 0x40 + x;
 155   1          LCD1602_cmd(addr | 0x80);
 156   1      }
 157          
 158          //显示字符串
 159          void LCD1602_Show(u8 x,u8 y,u8 *str)
 160          {
 161   1          LCD1602_SetRAM(x,y);
 162   1          while(*str != '\0')
 163   1          {
 164   2              LCD1602_Data(*str++);
 165   2          }
 166   1      }
 167          
 168          /*uart初始化函数*/
 169          void uart_init ()
 170          {
 171   1        ACC = P_SW1;
 172   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 173   1          P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 174   1        #if (PARITYBIT == NONE_PARITY)
 175   1          SCON = 0x50;                //8位可变波特率
 176   1        #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
                  SCON = 0xda;                //9位可变波特率,校验位初始为1
                #elif (PARITYBIT == SPACE_PARITY)
C51 COMPILER V9.59.0.0   MIAN                                                              08/15/2020 22:39:34 PAGE 4   

                  SCON = 0xd2;                //9位可变波特率,校验位初始为0
                #endif
 181   1      }
 182          
 183          /*串口数据发送*/
 184          void SendData(u8 dat)
 185          {
 186   1          while (busy);               //等待前面的数据发送完成
 187   1          ACC = dat;                  //获取校验位P (PSW.0)
 188   1          if (P)                      //根据P来设置校验位
 189   1          {
 190   2          #if (PARITYBIT == ODD_PARITY)
                    TB8 = 0;                //设置校验位为0
                  #elif (PARITYBIT == EVEN_PARITY)
                    TB8 = 1;                //设置校验位为1
                  #endif
 195   2          }
 196   1          else
 197   1          {
 198   2          #if (PARITYBIT == ODD_PARITY)
                        TB8 = 1;                //设置校验位为1
                  #elif (PARITYBIT == EVEN_PARITY)
                        TB8 = 0;                //设置校验位为0
                  #endif
 203   2          }
 204   1          busy = 1;
 205   1          SBUF = ACC;                 //写数据到UART数据寄存器
 206   1      }
 207          
 208          /*发送字符串*/
 209          void SendString(char *s)
 210          {
 211   1          while (*s)                  //检测字符串结束标志
 212   1          {
 213   2              SendData(*s++);         //发送当前字符
 214   2          }
 215   1      }
 216          
 217          //1000ms延时函数
 218          void Delay1000ms()    //@24.000MHz
 219          {
 220   1        unsigned char i, j, k;
 221   1      
 222   1        _nop_();
 223   1        _nop_();
 224   1        i = 92;
 225   1        j = 50;
 226   1        k = 238;
 227   1        do
 228   1        {
 229   2          do
 230   2          {
 231   3            while (--k);
 232   3          } while (--j);
 233   2        } while (--i);
 234   1      }
 235          
 236          
 237          /*uart中断服务程序*/
 238          void Uart() interrupt 4
 239          {
 240   1          if (RI)
C51 COMPILER V9.59.0.0   MIAN                                                              08/15/2020 22:39:34 PAGE 5   

 241   1          {
 242   2              RI = 0;                 //清除RI位
 243   2              // P0 = SBUF;              //P0显示串口数据
 244   2              P54 = RB8;              //P2.2显示校验位
 245   2          }
 246   1          if (TI)
 247   1          {
 248   2              TI = 0;                 //清除TI位
 249   2              busy = 0;               //清忙标志
 250   2          }
 251   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    404    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
